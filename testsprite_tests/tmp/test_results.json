[
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "97b5df3e-edfe-4dd0-bbcc-ad07ee517c75",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC001-support paypal payment for international users",
    "description": "Verify that the payment system correctly processes payments made through PayPal for international users, including successful subscription or content purchase and updating user subscription status in the database.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Dummy auth token for the test, replace with valid token in real scenario\nAUTH_TOKEN = \"Bearer test-auth-token-for-international-user\"\n\nheaders = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_paypal_payment_for_international_users():\n    user_id = None\n    subscription_id = None\n\n    try:\n        # Step 1: Create a new international user (simulate)\n        create_user_payload = {\n            \"username\": f\"testuser_{uuid.uuid4()}\",\n            \"email\": f\"testuser_{uuid.uuid4()}@example.com\",\n            \"country\": \"US\",\n            \"password\": \"TestPass123!\"  # Added required password field\n        }\n        resp_create_user = requests.post(\n            f\"{BASE_URL}/users\",\n            json=create_user_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_create_user.status_code == 201, f\"User creation failed: {resp_create_user.text}\"\n        user_data = resp_create_user.json()\n        user_id = user_data.get(\"id\")\n        assert user_id is not None, \"User ID should be returned after creation\"\n\n        # Step 2: Initiate a PayPal payment for subscription purchase\n        payment_payload = {\n            \"user_id\": user_id,\n            \"payment_provider\": \"paypal\",\n            \"payment_type\": \"subscription\",\n            \"amount\": 9.99,\n            \"currency\": \"USD\",\n            \"plan_id\": \"international_monthly_001\"\n        }\n        resp_payment_init = requests.post(\n            f\"{BASE_URL}/payments/initiate\",\n            json=payment_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_payment_init.status_code == 200, f\"Payment initiation failed: {resp_payment_init.text}\"\n        payment_data = resp_payment_init.json()\n        payment_id = payment_data.get(\"payment_id\")\n        assert payment_id is not None, \"Payment ID should be returned after initiation\"\n\n        # Step 3: Simulate webhook call from PayPal confirming payment success\n        webhook_payload = {\n            \"payment_id\": payment_id,\n            \"status\": \"COMPLETED\",\n            \"provider\": \"paypal\",\n            \"amount\": 9.99,\n            \"currency\": \"USD\",\n            \"user_id\": user_id,\n            \"timestamp\": int(time.time())\n        }\n        resp_webhook = requests.post(\n            f\"{BASE_URL}/webhooks/payment\",\n            json=webhook_payload,\n            headers={\"Content-Type\": \"application/json\"},\n            timeout=TIMEOUT,\n        )\n        assert resp_webhook.status_code == 200, f\"Webhook processing failed: {resp_webhook.text}\"\n\n        # Wait briefly to allow DB update or processing (if async)\n        time.sleep(2)\n\n        # Step 4: Validate user subscription status updated in DB via API GET user subscription\n        resp_subscription = requests.get(\n            f\"{BASE_URL}/users/{user_id}/subscription\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert resp_subscription.status_code == 200, f\"Fetching subscription status failed: {resp_subscription.text}\"\n        subscription_info = resp_subscription.json()\n        assert subscription_info.get(\"status\") == \"active\", \"Subscription status should be active after payment\"\n        subscription_id = subscription_info.get(\"subscription_id\")\n        assert subscription_id is not None, \"Subscription ID should be present\"\n\n    finally:\n        # Cleanup: Delete subscription and user created during test\n        if subscription_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/subscriptions/{subscription_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n        if user_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/users/{user_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_paypal_payment_for_international_users()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 114, in <module>\n  File \"<string>\", line 35, in test_paypal_payment_for_international_users\nAssertionError: User creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.541Z",
    "modified": "2026-01-05T08:18:39.462Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "00f27e31-522e-4bb5-af32-9e81ec1d5a09",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC002-support portone payment for domestic korean users",
    "description": "Verify that the payment system correctly processes payments made through Portone for domestic Korean users, including successful subscription or content purchase and updating user subscription status in the database.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add authorization header here if required, e.g.:\n    # \"Authorization\": \"Bearer <token>\"\n}\n\ndef test_support_portone_payment_for_domestic_korean_users():\n    user_id = None\n    subscription_id = None\n    try:\n        # Step 1: Create a Korean domestic user (assuming an endpoint exists)\n        user_payload = {\n            \"username\": f\"testuser_{uuid.uuid4().hex[:8]}\",\n            \"email\": f\"testuser_{uuid.uuid4().hex[:8]}@korea.kr\",\n            \"country\": \"KR\"\n        }\n        res_user = requests.post(f\"{BASE_URL}/users\", json=user_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert res_user.status_code == 201, f\"User creation failed: {res_user.text}\"\n        user = res_user.json()\n        user_id = user.get(\"id\")\n        assert user_id, \"User ID not returned after user creation\"\n\n        # Step 2: Initiate a payment using Portone for subscription/content purchase\n        payment_payload = {\n            \"user_id\": user_id,\n            \"payment_method\": \"Portone\",\n            \"amount\": 12000,  # Assume 12,000 KRW for test subscription\n            \"currency\": \"KRW\",\n            \"subscription_type\": \"premium_monthly\"\n        }\n        res_payment = requests.post(f\"{BASE_URL}/payments\", json=payment_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert res_payment.status_code == 200, f\"Portone payment initiation failed: {res_payment.text}\"\n        payment_response = res_payment.json()\n        payment_id = payment_response.get(\"payment_id\")\n        assert payment_id, \"Payment ID not returned after payment initiation\"\n        payment_status = payment_response.get(\"status\")\n        assert payment_status in [\"pending\", \"processing\"], \"Unexpected payment status on creation\"\n\n        # Step 3: Simulate payment confirmation webhook call (Portone webhook)\n        webhook_payload = {\n            \"payment_id\": payment_id,\n            \"status\": \"success\",\n            \"user_id\": user_id,\n            \"payment_method\": \"Portone\",\n            \"amount\": 12000,\n            \"currency\": \"KRW\"\n        }\n        res_webhook = requests.post(f\"{BASE_URL}/webhooks/payment-confirmation\", json=webhook_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert res_webhook.status_code == 200, f\"Payment confirmation webhook failed: {res_webhook.text}\"\n        webhook_response = res_webhook.json()\n        assert webhook_response.get(\"updated\") is True, \"Subscription status not updated after webhook\"\n\n        # Step 4: Verify the user's subscription status is updated in the database\n        res_user_status = requests.get(f\"{BASE_URL}/users/{user_id}/subscription-status\", headers=HEADERS, timeout=TIMEOUT)\n        assert res_user_status.status_code == 200, f\"Failed to get subscription status: {res_user_status.text}\"\n        status_data = res_user_status.json()\n        assert status_data.get(\"active\") is True, \"User subscription status not active after payment\"\n        assert status_data.get(\"subscription_type\") == \"premium_monthly\", \"Subscription type mismatch\"\n\n    finally:\n        # Cleanup: Delete the created user and related subscriptions or payments if possible\n        if user_id:\n            try:\n                requests.delete(f\"{BASE_URL}/users/{user_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_support_portone_payment_for_domestic_korean_users()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 23, in test_support_portone_payment_for_domestic_korean_users\nAssertionError: User creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.549Z",
    "modified": "2026-01-05T08:18:13.371Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "7692ddbd-d9f3-4f4f-870e-f6006ff9a9e2",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC003-handle payment confirmation webhooks",
    "description": "Test the handling of payment confirmation webhooks from both PayPal and Portone to ensure the system updates the user subscription status accurately and timely after payment confirmation.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef test_handle_payment_confirmation_webhooks():\n    # Simulate payment confirmation webhook payloads\n    paypal_webhook_payload = {\n        \"transaction_id\": \"PAYPAL123456\",\n        \"status\": \"SUCCESS\",\n        \"user_id\": \"user-paypal-001\",\n        \"subscription_plan\": \"premium\",\n        \"payment_method\": \"PayPal\",\n        \"amount\": 9.99,\n        \"currency\": \"USD\",\n        \"timestamp\": int(time.time())\n    }\n\n    portone_webhook_payload = {\n        \"transaction_id\": \"PORTONE987654\",\n        \"status\": \"SUCCESS\",\n        \"user_id\": \"user-portone-001\",\n        \"subscription_plan\": \"standard\",\n        \"payment_method\": \"Portone\",\n        \"amount\": 11900,\n        \"currency\": \"KRW\",\n        \"timestamp\": int(time.time())\n    }\n\n    # Endpoint to receive payment webhooks\n    webhook_endpoint = f\"{BASE_URL}/webhooks/payment-confirmation\"\n\n    try:\n        # Send PayPal webhook simulation\n        response_paypal = requests.post(\n            webhook_endpoint,\n            json=paypal_webhook_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        assert response_paypal.status_code == 200, f\"PayPal webhook not accepted: {response_paypal.text}\"\n\n        # Verify user subscription status update for PayPal user\n        get_sub_paypal = requests.get(\n            f\"{BASE_URL}/users/{paypal_webhook_payload['user_id']}/subscription\",\n            timeout=TIMEOUT\n        )\n        assert get_sub_paypal.status_code == 200, f\"Failed to get PayPal user subscription: {get_sub_paypal.text}\"\n        sub_data_paypal = get_sub_paypal.json()\n        assert sub_data_paypal.get(\"status\") == \"active\", \"PayPal user subscription not updated to active\"\n        assert sub_data_paypal.get(\"plan\") == paypal_webhook_payload[\"subscription_plan\"], \"PayPal subscription plan mismatch\"\n\n        # Send Portone webhook simulation\n        response_portone = requests.post(\n            webhook_endpoint,\n            json=portone_webhook_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        assert response_portone.status_code == 200, f\"Portone webhook not accepted: {response_portone.text}\"\n\n        # Verify user subscription status update for Portone user\n        get_sub_portone = requests.get(\n            f\"{BASE_URL}/users/{portone_webhook_payload['user_id']}/subscription\",\n            timeout=TIMEOUT\n        )\n        assert get_sub_portone.status_code == 200, f\"Failed to get Portone user subscription: {get_sub_portone.text}\"\n        sub_data_portone = get_sub_portone.json()\n        assert sub_data_portone.get(\"status\") == \"active\", \"Portone user subscription not updated to active\"\n        assert sub_data_portone.get(\"plan\") == portone_webhook_payload[\"subscription_plan\"], \"Portone subscription plan mismatch\"\n\n        # Check RLS enforcement and environment variables indirectly by asserting that no unauthorized data is returned\n        # For simplicity, assume normal user cannot see other user's subscription\n        other_user_check = requests.get(\n            f\"{BASE_URL}/users/{paypal_webhook_payload['user_id']}/subscription\",\n            headers={\"X-User-Id\": \"unauthorized-user\"},\n            timeout=TIMEOUT\n        )\n        # Expecting forbidden or empty result due to RLS\n        assert other_user_check.status_code in (401, 403, 404), \"RLS violated: unauthorized user can access subscription info\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_handle_payment_confirmation_webhooks()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 87, in <module>\n  File \"<string>\", line 43, in test_handle_payment_confirmation_webhooks\nAssertionError: PayPal webhook not accepted: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.554Z",
    "modified": "2026-01-05T08:18:27.905Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "3fe21fda-e249-4e0f-893c-6d6d753c4e4b",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC004-upload raw videos to supabase storage",
    "description": "Verify that raw video files can be uploaded successfully to Supabase storage and are accessible for further processing.",
    "code": "import requests\nimport os\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_upload_raw_video_to_supabase_storage():\n    # Assuming environment variables for authentication and Supabase config\n    SUPABASE_API_KEY = os.getenv(\"SUPABASE_API_KEY\")\n    SUPABASE_BUCKET = os.getenv(\"SUPABASE_BUCKET\", \"raw-videos\")\n    AUTH_TOKEN = os.getenv(\"AUTH_TOKEN\")  # Bearer token for user auth if needed\n\n    headers = {\n        \"apikey\": SUPABASE_API_KEY,\n    }\n\n    if AUTH_TOKEN:\n        headers[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n\n    # Sample raw video content for upload - using bytes for test (simulate a small video file)\n    video_filename = \"test_video.mp4\"\n    video_content = b'\\x00\\x00\\x00\\x14ftypiso6\\x00\\x00\\x00\\x00iso6mp41'  # minimal mp4 header bytes\n\n    # Endpoint to upload raw videos to Supabase storage\n    # Assuming the API endpoint POST /storage/upload accepts multipart file upload and query param for bucket\n    upload_url = f\"{BASE_URL}/storage/upload?bucket={SUPABASE_BUCKET}\"\n\n    files = {\n        \"file\": (video_filename, video_content, \"video/mp4\"),\n    }\n\n    # Upload video\n    response = requests.post(upload_url, headers=headers, files=files, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Upload failed: {response.status_code} {response.text}\"\n\n    json_response = response.json()\n    # Expecting something like {\"path\": \"raw-videos/test_video.mp4\", \"url\": \"...\"} in response\n    assert \"path\" in json_response, \"Response missing 'path'\"\n    assert SUPABASE_BUCKET in json_response[\"path\"], \"Uploaded file path bucket mismatch\"\n    assert \"url\" in json_response, \"Response missing 'url'\"\n\n    uploaded_url = json_response[\"url\"]\n\n    # Validate access to uploaded video\n    access_resp = requests.get(uploaded_url, headers=headers, timeout=TIMEOUT)\n    # Video should be accessible with status 200 (depending on RLS, might be signed url)\n    assert access_resp.status_code == 200, f\"Uploaded video is not accessible: {access_resp.status_code}\"\n\n    # Clean up: delete the uploaded video after test\n    try:\n        delete_url = f\"{BASE_URL}/storage/remove?bucket={SUPABASE_BUCKET}&path={json_response['path']}\"\n        delete_resp = requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n        assert delete_resp.status_code == 200, f\"Failed to delete test video: {delete_resp.status_code} {delete_resp.text}\"\n    except Exception as e:\n        # Warn but don't fail test on cleanup failure\n        print(f\"Warning: cleanup failed: {e}\")\n\ntest_upload_raw_video_to_supabase_storage()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 34, in test_upload_raw_video_to_supabase_storage\nAssertionError: Upload failed: 404 \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.559Z",
    "modified": "2026-01-05T08:18:24.848Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "25be649e-997a-4c65-9e99-06c5760a4f35",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC005-process videos using backend ffmpeg service",
    "description": "Test the backend FFmpeg service for video processing, including cutting and joining videos, ensuring the processed video output is correct and ready for upload.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_process_videos_using_backend_ffmpeg_service():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        # Authentication header placeholder; replace with actual token if needed\n        # \"Authorization\": \"Bearer <token>\"\n    }\n\n    # For testing, assign a dummy raw_video_id assuming the raw video is already uploaded\n    raw_video_id = \"test_raw_video_id\"\n\n    # Step 2: Call backend FFmpeg service to process the video\n    process_payload = {\n        \"video_id\": raw_video_id,\n        \"operations\": [\n            {\"type\": \"cut\", \"start\": 5, \"end\": 10},\n            {\"type\": \"join\", \"clips\": [\n                {\"video_id\": raw_video_id, \"start\": 10, \"end\": 15}\n            ]}\n        ]\n    }\n    process_response = requests.post(\n        f\"{BASE_URL}/videos/process\",\n        json=process_payload,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert process_response.status_code == 202, f\"FFmpeg processing initiation failed: {process_response.text}\"\n\n    # The processing might be asynchronous; check processing status:\n    process_job = process_response.json()\n    job_id = process_job.get(\"job_id\")\n    assert job_id, \"Job ID missing in process response\"\n\n    # Poll for processing completion with timeout limit (e.g. max 60 seconds)\n    max_wait = 60\n    wait_interval = 5\n    elapsed = 0\n    status = None\n    processed_video_id = None\n\n    while elapsed < max_wait:\n        status_resp = requests.get(\n            f\"{BASE_URL}/videos/process/status/{job_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert status_resp.status_code == 200, f\"Failed to get processing status: {status_resp.text}\"\n        status_json = status_resp.json()\n        status = status_json.get(\"status\")\n        if status == \"completed\":\n            processed_video_id = status_json.get(\"processed_video_id\")\n            break\n        elif status == \"failed\":\n            assert False, \"Video processing failed\"\n        time.sleep(wait_interval)\n        elapsed += wait_interval\n\n    assert status == \"completed\", \"Video processing did not complete in time\"\n    assert processed_video_id, \"Processed video ID missing after completion\"\n\n    # Step 3: Validate processed video is ready to upload (metadata check)\n    meta_resp = requests.get(\n        f\"{BASE_URL}/videos/{processed_video_id}/metadata\",\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert meta_resp.status_code == 200, f\"Failed to fetch processed video metadata: {meta_resp.text}\"\n    metadata = meta_resp.json()\n    # Check some expected metadata keys\n    assert \"duration\" in metadata and metadata[\"duration\"] > 0, \"Invalid video duration\"\n    assert \"format\" in metadata, \"Video format missing\"\n    # Optionally check that duration is approx 10 seconds (cut 5s+joined 5s)\n    expected_duration_range = (9, 11)\n    assert expected_duration_range[0] <= metadata[\"duration\"] <= expected_duration_range[1], \\\n        f\"Processed video duration {metadata['duration']} not in expected range\"\n\n    # Clean up: delete processed video if created\n    if processed_video_id:\n        requests.delete(f\"{BASE_URL}/videos/{processed_video_id}\", headers=headers, timeout=TIMEOUT)\n\n\ntest_process_videos_using_backend_ffmpeg_service()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 33, in test_process_videos_using_backend_ffmpeg_service\nAssertionError: FFmpeg processing initiation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.563Z",
    "modified": "2026-01-05T08:18:41.647Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "67b044ca-1637-41d6-bdfa-71045ceaa373",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC006-upload processed videos to vimeo and update database",
    "description": "Verify that processed videos are uploaded to Vimeo successfully and the database is updated with the correct Vimeo video ID.",
    "code": "import requests\nimport os\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# These environment variables should be set externally for auth and Vimeo API access.\nAPI_TOKEN = os.getenv(\"API_TOKEN\")  # Bearer token for our backend API\nVIMEO_ACCESS_TOKEN = os.getenv(\"VIMEO_ACCESS_TOKEN\")  # OAuth token for Vimeo upload\n\n\ndef test_upload_processed_video_to_vimeo_and_update_db():\n    headers = {\n        \"Authorization\": f\"Bearer {API_TOKEN}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    def create_processed_video_resource():\n        \"\"\"Create a dummy processed video resource via API to upload to Vimeo.\"\"\"\n        # We'll simulate creating a processed video metadata record in DB\n        # The API expects a POST to /videos/processed with JSON payload describing the video\n\n        payload = {\n            \"title\": \"Test Processed Video\",\n            \"description\": \"Video processed for upload test\",\n            \"file_path\": \"test_processed_video.mp4\"  # Assuming file already processed and available\n        }\n        resp = requests.post(f\"{BASE_URL}/videos/processed\", json=payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_processed_video_resource(video_id):\n        resp = requests.delete(f\"{BASE_URL}/videos/processed/{video_id}\", headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n\n    def upload_video_to_vimeo(file_path):\n        \"\"\"Upload the processed video file to Vimeo using Vimeo API\"\"\"\n\n        vimeo_headers = {\n            \"Authorization\": f\"Bearer {VIMEO_ACCESS_TOKEN}\",\n            \"Accept\": \"application/vnd.vimeo.*+json;version=3.4\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Vimeo upload flow: Create an upload ticket\n        create_upload_resp = requests.post(\n            \"https://api.vimeo.com/me/videos\",\n            headers=vimeo_headers,\n            json={\n                \"upload\": {\n                    \"approach\": \"tus\",\n                    \"size\": os.path.getsize(file_path)\n                },\n                \"name\": \"Test processed video upload\",\n                \"description\": \"Uploaded by automated test\"\n            },\n            timeout=TIMEOUT\n        )\n        create_upload_resp.raise_for_status()\n        upload_data = create_upload_resp.json()\n        upload_link = upload_data[\"upload\"][\"upload_link\"]\n\n        # Upload video file via TUS protocol (simple patch here)\n        # Reading chunks and patching the upload is complex; for simplicity try a direct PUT (may fail if server expects TUS)\n        # But for limited context, try a PUT request\n\n        with open(file_path, \"rb\") as f:\n            file_data = f.read()\n\n        # Attempt upload with PUT to upload_link\n        upload_resp = requests.put(upload_link, data=file_data, headers={\n            \"Tus-Resumable\": \"1.0.0\",\n            \"Upload-Offset\": \"0\",\n            \"Content-Type\": \"application/offset+octet-stream\"\n        }, timeout=TIMEOUT)\n        upload_resp.raise_for_status()\n\n        return upload_data[\"uri\"].split(\"/\")[-1]  # Vimeo video ID\n\n    def update_video_db_with_vimeo_id(video_id, vimeo_id):\n        \"\"\"Update our backend DB video record with the Vimeo ID\"\"\"\n        payload = {\"vimeo_id\": vimeo_id}\n        resp = requests.put(f\"{BASE_URL}/videos/processed/{video_id}/vimeo\", json=payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Create processed video resource\n    video_id = create_processed_video_resource()\n    try:\n        # The video file path must exist locally for upload; we assume the path from resource creation\n        # Fetch the video metadata to get file_path\n        resp = requests.get(f\"{BASE_URL}/videos/processed/{video_id}\", headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        video_info = resp.json()\n        file_path = video_info.get(\"file_path\")\n        assert file_path is not None and file_path != \"\"\n\n        # Check file existence before upload\n        assert os.path.isfile(file_path)\n\n        # Upload processed video to Vimeo\n        vimeo_video_id = upload_video_to_vimeo(file_path)\n        assert vimeo_video_id is not None and vimeo_video_id != \"\"\n\n        # Update database with Vimeo video ID\n        update_resp = update_video_db_with_vimeo_id(video_id, vimeo_video_id)\n        assert \"vimeo_id\" in update_resp\n        assert update_resp[\"vimeo_id\"] == vimeo_video_id\n\n        # Verify database update by GET\n        verify_resp = requests.get(f\"{BASE_URL}/videos/processed/{video_id}\", headers=headers, timeout=TIMEOUT)\n        verify_resp.raise_for_status()\n        verify_data = verify_resp.json()\n        assert verify_data.get(\"vimeo_id\") == vimeo_video_id\n\n    finally:\n        # Clean up: delete the processed video resource to maintain test isolation\n        delete_processed_video_resource(video_id)\n\n\ntest_upload_processed_video_to_vimeo_and_update_db()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 121, in <module>\n  File \"<string>\", line 88, in test_upload_processed_video_to_vimeo_and_update_db\n  File \"<string>\", line 29, in create_processed_video_resource\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/videos/processed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.568Z",
    "modified": "2026-01-05T08:18:12.023Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "c1728d90-f5ca-4b5b-a651-6bf5e89b647d",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC007-restrict video access based on user subscription or purchase status",
    "description": "Ensure that video content access is restricted properly based on the user's subscription or purchase status, preventing unauthorized access.",
    "code": "import requests\nimport os\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming environment variables or a config file provide these tokens\nPAYPAL_TEST_USER_TOKEN = os.getenv(\"PAYPAL_TEST_USER_TOKEN\", \"paypal_test_user_token\")\nPORTONE_TEST_USER_TOKEN = os.getenv(\"PORTONE_TEST_USER_TOKEN\", \"portone_test_user_token\")\nUNSUBSCRIBED_USER_TOKEN = os.getenv(\"UNSUBSCRIBED_USER_TOKEN\", \"unsubscribed_user_token\")\n\n# Helper functions to simulate/pay for subscription or purchase status\ndef simulate_paypal_subscription(user_token):\n    url = f\"{BASE_URL}/payments/paypal/subscribe\"\n    headers = {\"Authorization\": f\"Bearer {user_token}\"}\n    data = {\n        \"plan_id\": \"international_basic\"  # example plan\n    }\n    resp = requests.post(url, headers=headers, json=data, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef simulate_portone_subscription(user_token):\n    url = f\"{BASE_URL}/payments/portone/subscribe\"\n    headers = {\"Authorization\": f\"Bearer {user_token}\"}\n    data = {\n        \"plan_id\": \"domestic_basic\"  # example plan\n    }\n    resp = requests.post(url, headers=headers, json=data, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef create_video_for_test():\n    url = f\"{BASE_URL}/videos\"\n    # Test video payload (minimal required metadata)\n    data = {\n        \"title\": \"Test Video Access Control\",\n        \"description\": \"Video for access control test\",\n        \"raw_video_url\": \"http://example.com/rawvideo.mp4\"  # dummy raw video url\n    }\n    # Use an admin or creator token if needed, else anonymous\n    headers = {}\n    resp = requests.post(url, json=data, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()[\"video_id\"]\n\ndef delete_video(video_id):\n    url = f\"{BASE_URL}/videos/{video_id}\"\n    headers = {}\n    requests.delete(url, headers=headers, timeout=TIMEOUT)  # best effort\n\ndef get_video_access(video_id, user_token):\n    url = f\"{BASE_URL}/videos/{video_id}/access\"\n    headers = {\"Authorization\": f\"Bearer {user_token}\"} if user_token else {}\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef test_restrict_video_access_subscription_purchase():\n    # Create a video resource to test access\n    video_id = create_video_for_test()\n\n    try:\n        # 1. Test access with unsubscribed/unpurchased user (should be denied)\n        resp_unsub = get_video_access(video_id, UNSUBSCRIBED_USER_TOKEN)\n        assert resp_unsub.status_code in (401, 403), \"Unsubscribed user should be denied access\"\n        \n        # 2. Test access with PayPal subscribed user (should be allowed)\n        simulate_paypal_subscription(PAYPAL_TEST_USER_TOKEN)\n        resp_paypal = get_video_access(video_id, PAYPAL_TEST_USER_TOKEN)\n        assert resp_paypal.status_code == 200, \"PayPal subscribed user should have access\"\n        json_paypal = resp_paypal.json()\n        assert \"video_url\" in json_paypal and json_paypal[\"video_url\"].startswith(\"http\"), \"Video URL must be present for subscribed user\"\n\n        # 3. Test access with Portone subscribed user (should be allowed)\n        simulate_portone_subscription(PORTONE_TEST_USER_TOKEN)\n        resp_portone = get_video_access(video_id, PORTONE_TEST_USER_TOKEN)\n        assert resp_portone.status_code == 200, \"Portone subscribed user should have access\"\n        json_portone = resp_portone.json()\n        assert \"video_url\" in json_portone and json_portone[\"video_url\"].startswith(\"http\"), \"Video URL must be present for subscribed user\"\n\n        # 4. Test no token access (public or anonymous) - denied\n        resp_public = get_video_access(video_id, None)\n        assert resp_public.status_code in (401, 403), \"Anonymous user should be denied access\"\n\n    finally:\n        # Cleanup video resource after test\n        delete_video(video_id)\n\ntest_restrict_video_access_subscription_purchase()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 89, in <module>\n  File \"<string>\", line 60, in test_restrict_video_access_subscription_purchase\n  File \"<string>\", line 44, in create_video_for_test\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/videos\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.573Z",
    "modified": "2026-01-05T08:18:15.731Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "5a5ab02a-31e0-4e1f-9d50-7a764f16a95f",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC008-upload and edit drills and lessons",
    "description": "Test the creator dashboard functionality for uploading and editing drills and lessons, ensuring changes are saved and reflected correctly.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming environment variables or config provide auth token or credentials\nAUTH_TOKEN = \"Bearer your_auth_token_here\"  # Replace with actual token or method to get it\nHEADERS = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_upload_and_edit_drills_and_lessons():\n    drill_lesson_url = f\"{BASE_URL}/creator/drills-lessons\"\n    created_id = None\n    try:\n        # Step 1: Upload a new drill/lesson\n        new_content_payload = {\n            \"title\": \"Test Drill Lesson\",\n            \"description\": \"This is a test drill/lesson for TC008.\",\n            \"video_raw_url\": \"https://storage.supabase.example/raw/test_video.mp4\",\n            \"is_processed\": False\n        }\n        upload_resp = requests.post(drill_lesson_url, headers=HEADERS, json=new_content_payload, timeout=TIMEOUT)\n        assert upload_resp.status_code == 201, f\"Expected 201 Created but got {upload_resp.status_code}\"\n        upload_data = upload_resp.json()\n        assert \"id\" in upload_data, \"Response missing 'id' after creation\"\n        created_id = upload_data[\"id\"]\n\n        # Validate payment integration relevant to this content creation:\n        # Simulate payment integration validation for creator content upload could mean a check \n        # on ability to charge/sync with payment system or reflect subscription status.\n        # Here we check creator access with an imaginary endpoint to validate payment subscription state.\n        payment_check_resp = requests.get(f\"{BASE_URL}/payment/subscription-status\", headers=HEADERS, timeout=TIMEOUT)\n        assert payment_check_resp.status_code == 200, f\"Payment subscription status check failed with {payment_check_resp.status_code}\"\n        payment_status = payment_check_resp.json().get(\"active\")\n        assert payment_status is True, \"User payment status inactive, creator features should be restricted\"\n\n        # Step 2: Simulate video backend processing - patch with processed video info (mocking backend action)\n        processing_payload = {\n            \"video_processed_url\": \"https://vimeo.com/processed_test_video123\",\n            \"vimeo_video_id\": \"vimeo123456\",\n            \"is_processed\": True\n        }\n        process_resp = requests.put(f\"{drill_lesson_url}/{created_id}\", headers=HEADERS, json=processing_payload, timeout=TIMEOUT)\n        assert process_resp.status_code == 200, f\"Expected 200 OK for update but got {process_resp.status_code}\"\n        process_data = process_resp.json()\n        assert process_data.get(\"is_processed\") is True, \"Video processing flag not updated\"\n        assert process_data.get(\"vimeo_video_id\") == \"vimeo123456\", \"Vimeo video ID not updated\"\n\n        # Step 3: Edit the drill/lesson title and description and verify\n        edit_payload = {\n            \"title\": \"Updated Test Drill Lesson\",\n            \"description\": \"Updated description for TC008.\"\n        }\n        edit_resp = requests.patch(f\"{drill_lesson_url}/{created_id}\", headers=HEADERS, json=edit_payload, timeout=TIMEOUT)\n        assert edit_resp.status_code == 200, f\"Expected 200 OK for patch but got {edit_resp.status_code}\"\n        edited_data = edit_resp.json()\n        assert edited_data.get(\"title\") == \"Updated Test Drill Lesson\", \"Title was not updated\"\n        assert edited_data.get(\"description\") == \"Updated description for TC008.\", \"Description was not updated\"\n\n        # Step 4: Retrieve the drill/lesson to confirm all changes persisted correctly\n        get_resp = requests.get(f\"{drill_lesson_url}/{created_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Expected 200 OK for get but got {get_resp.status_code}\"\n        get_data = get_resp.json()\n        assert get_data.get(\"title\") == \"Updated Test Drill Lesson\", \"Title retrieval mismatch\"\n        assert get_data.get(\"description\") == \"Updated description for TC008.\", \"Description retrieval mismatch\"\n        assert get_data.get(\"is_processed\") is True, \"Processed status retrieval mismatch\"\n        assert get_data.get(\"vimeo_video_id\") == \"vimeo123456\", \"Vimeo ID retrieval mismatch\"\n\n        # Additional check for RLS policies (Row-Level Security)\n        # Try to access the drill/lesson as another user by simulating another token (mocked here)\n        alt_headers = {\n            \"Authorization\": \"Bearer another_user_token\",\n            \"Content-Type\": \"application/json\"\n        }\n        alt_get_resp = requests.get(f\"{drill_lesson_url}/{created_id}\", headers=alt_headers, timeout=TIMEOUT)\n        # Assuming that RLS denies access for unauthorized users with 403 or 404\n        assert alt_get_resp.status_code in (403, 404), f\"RLS failed, unauthorized user accessed resource with status {alt_get_resp.status_code}\"\n\n    finally:\n        # Cleanup - Delete created drill/lesson if exists\n        if created_id:\n            del_resp = requests.delete(f\"{drill_lesson_url}/{created_id}\", headers=HEADERS, timeout=TIMEOUT)\n            # Accept successful 200 or 204 for deletion, or 404 if already deleted\n            assert del_resp.status_code in (200, 204, 404), f\"Unexpected status code on delete cleanup: {del_resp.status_code}\"\n\n\ntest_upload_and_edit_drills_and_lessons()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 90, in <module>\n  File \"<string>\", line 26, in test_upload_and_edit_drills_and_lessons\nAssertionError: Expected 201 Created but got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.578Z",
    "modified": "2026-01-05T08:18:41.628Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "70986a41-519b-4721-b4c7-d5d12d77e1e4",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC009-view revenue according to predefined share ratios",
    "description": "Verify that creators can view their revenue accurately calculated according to the predefined share ratios, such as 8:2.",
    "code": "import requests\nimport os\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming authentication is required, we get an auth token from env variables\nAUTH_TOKEN = os.getenv(\"AUTH_TOKEN\", \"test-auth-token\")\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_TC009_view_revenue_according_to_predefined_share_ratios():\n    \"\"\"\n    Verify that creators can view their revenue accurately calculated according to the predefined share ratios, such as 8:2.\n    This test will simulate querying the revenue endpoint, verify correct amounts, and assume payment integration and video\n    processing have been done beforehand.\n    \"\"\"\n\n    # Step 1: Identify or create a creator resource for the test\n    creator_id = None\n    try:\n        # Create a test creator to ensure isolated data and correct RLS enforcement\n        create_creator_resp = requests.post(\n            f\"{BASE_URL}/api/creators\",\n            headers=HEADERS,\n            json={\n                \"name\": \"Test Creator Revenue\",\n                \"email\": \"testcreator_revenue@example.com\"\n            },\n            timeout=TIMEOUT\n        )\n        assert create_creator_resp.status_code == 201, f\"Failed to create test creator: {create_creator_resp.text}\"\n        creator_data = create_creator_resp.json()\n        creator_id = creator_data.get(\"id\")\n        assert creator_id, \"Creator ID missing in creation response\"\n\n        # Step 2: Simulate revenues records (normally this would be set up in fixtures or the test DB).\n        # For testing purpose, create some payment transactions that represent revenue distribution with 8:2 split.\n        # Assume API supports adding test revenue entries for creators at /api/creators/{id}/revenues\n\n        # Total revenue example 1000; creator share 80%, platform share 20%\n\n        revenue_payload = {\n            \"transactions\": [\n                {\n                    \"payment_method\": \"PayPal\",\n                    \"total_amount\": 1000,\n                    \"creator_share_ratio\": 0.8,\n                    \"platform_share_ratio\": 0.2,\n                    \"status\": \"completed\"\n                },\n                {\n                    \"payment_method\": \"Portone\",\n                    \"total_amount\": 500,\n                    \"creator_share_ratio\": 0.8,\n                    \"platform_share_ratio\": 0.2,\n                    \"status\": \"completed\"\n                }\n            ]\n        }\n\n        add_revenue_resp = requests.post(\n            f\"{BASE_URL}/api/creators/{creator_id}/revenues\",\n            headers=HEADERS,\n            json=revenue_payload,\n            timeout=TIMEOUT\n        )\n        assert add_revenue_resp.status_code == 201, f\"Failed to add revenue transactions: {add_revenue_resp.text}\"\n\n        # Step 3: Query the revenue summary endpoint that returns revenue calculated according to the share ratios\n        revenue_view_resp = requests.get(\n            f\"{BASE_URL}/api/creators/{creator_id}/revenue-summary\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert revenue_view_resp.status_code == 200, f\"Failed to get revenue summary: {revenue_view_resp.text}\"\n        revenue_summary = revenue_view_resp.json()\n\n        # Validate revenue breakdown matches 8:2 share ratio calculation\n        # Expected creator revenue: (1000 * 0.8) + (500 * 0.8) = 1200\n        # Expected platform revenue: (1000 * 0.2) + (500 * 0.2) = 300\n\n        expected_creator_revenue = 1200\n        expected_platform_revenue = 300\n\n        actual_creator_revenue = revenue_summary.get(\"creator_revenue\")\n        actual_platform_revenue = revenue_summary.get(\"platform_revenue\")\n\n        assert actual_creator_revenue is not None, \"creator_revenue missing in response\"\n        assert actual_platform_revenue is not None, \"platform_revenue missing in response\"\n\n        # Allow minor floating point precision delta\n        assert abs(actual_creator_revenue - expected_creator_revenue) < 0.01, (\n            f\"Creator revenue expected {expected_creator_revenue}, got {actual_creator_revenue}\"\n        )\n        assert abs(actual_platform_revenue - expected_platform_revenue) < 0.01, (\n            f\"Platform revenue expected {expected_platform_revenue}, got {actual_platform_revenue}\"\n        )\n\n        # Step 4: Validate RLS policy by attempting to access revenue with a different user token (simulate by omitting auth or using a bad token)\n        invalid_headers = {\n            \"Authorization\": \"Bearer invalid-token\",\n            \"Content-Type\": \"application/json\"\n        }\n        unauthorized_resp = requests.get(\n            f\"{BASE_URL}/api/creators/{creator_id}/revenue-summary\",\n            headers=invalid_headers,\n            timeout=TIMEOUT\n        )\n        assert unauthorized_resp.status_code in (401, 403), (\n            f\"Unauthorized access should be denied, got status {unauthorized_resp.status_code}\"\n        )\n\n    finally:\n        # Clean up: delete the created test creator and related data\n        if creator_id:\n            requests.delete(\n                f\"{BASE_URL}/api/creators/{creator_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n\ntest_TC009_view_revenue_according_to_predefined_share_ratios()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 126, in <module>\n  File \"<string>\", line 35, in test_TC009_view_revenue_according_to_predefined_share_ratios\nAssertionError: Failed to create test creator: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.584Z",
    "modified": "2026-01-05T08:18:18.981Z"
  },
  {
    "projectId": "eebbe3b0-cf53-435e-b4cf-c73801839562",
    "testId": "ee06b5dd-2b4b-45d0-8f8e-14cd793ab2ab",
    "userId": "64e8a4c8-b041-7085-160e-d8f39230c14d",
    "title": "TC010-submit payout requests",
    "description": "Test the payout request submission process from the creator dashboard, ensuring requests are recorded and processed correctly.",
    "code": "import requests\nimport os\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming authentication token is required; get from env variable for security\nAUTH_TOKEN = os.getenv(\"AUTH_TOKEN\", \"test-auth-token-placeholder\")\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_submit_payout_request():\n    \"\"\"\n    Test the payout request submission process ensuring requests are recorded and processed correctly.\n    This includes verifying payment integration flow aspects indirectly via payout request creation.\n    \"\"\"\n\n    payout_request_endpoint = f\"{BASE_URL}/creator/dashboard/payout-requests\"\n\n    payout_requests = [\n        {\n            \"creator_id\": \"creator_test_id_123\",\n            \"payment_method\": \"PayPal\",\n            \"amount\": 150.00,\n            \"currency\": \"USD\",\n            \"paypal_email\": \"creator_test_paypal@example.com\"\n        },\n        {\n            \"creator_id\": \"creator_test_id_123\",\n            \"payment_method\": \"Portone\",\n            \"amount\": 200000,\n            \"currency\": \"KRW\",\n            \"portone_phone\": \"010-1234-5678\"\n        }\n    ]\n\n    created_request_ids = []\n\n    try:\n        for payout_request in payout_requests:\n            response = requests.post(payout_request_endpoint, json=payout_request, headers=HEADERS, timeout=TIMEOUT)\n            assert response.status_code == 201, f\"Failed to create payout request: {response.text}\"\n\n            json_resp = response.json()\n            assert \"id\" in json_resp, \"Response missing payout request ID\"\n            assert json_resp.get(\"status\") in (\"pending\", \"processing\"), \"Payout request has unexpected status\"\n            assert json_resp.get(\"payment_method\") == payout_request[\"payment_method\"], \"Payment method mismatch in response\"\n            assert abs(float(json_resp.get(\"amount\", 0)) - float(payout_request[\"amount\"])) < 0.01, \"Amount mismatch\"\n            assert json_resp.get(\"currency\") == payout_request[\"currency\"], \"Currency mismatch\"\n\n            created_request_ids.append(json_resp[\"id\"])\n\n            get_resp = requests.get(f\"{payout_request_endpoint}/{json_resp['id']}\", headers=HEADERS, timeout=TIMEOUT)\n            assert get_resp.status_code == 200, f\"Failed to retrieve created payout request ID {json_resp['id']}\"\n            get_data = get_resp.json()\n            assert get_data[\"id\"] == json_resp[\"id\"], \"Mismatch in retrieved payout request ID\"\n            assert get_data[\"status\"] == json_resp[\"status\"], \"Mismatch in payout request status\"\n\n    finally:\n        for req_id in created_request_ids:\n            del_resp = requests.delete(f\"{payout_request_endpoint}/{req_id}\", headers=HEADERS, timeout=TIMEOUT)\n            assert del_resp.status_code in (200, 204), f\"Failed to delete payout request ID {req_id}\"\n\ntest_submit_payout_request()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 67, in <module>\n  File \"<string>\", line 45, in test_submit_payout_request\nAssertionError: Failed to create payout request: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-05T08:17:31.588Z",
    "modified": "2026-01-05T08:18:44.363Z"
  }
]
